float xleadin = 40;
float yleadin = 0;
float zleadin = 0; 
int rapidfeed = 60000;
int slowfeed = 30000;
int strikeRate = 800;  //1/800 = 0.075 seconds

float xoffset = 15; //tool offset from strike postion, in this case its head diameter increase to make the strike harder
float yoffset = 0;
float zoffset = -28; //a tweak value for how high to hit on the keys. 

float xhome = 280; //0,0,0 for the piano is its bottom centre, this is the position offset from machine center
float yhome = 0;
float zhome = 20;

float xinit = -180; //initial poise postion to get ready for piano playing 
float yinit = 0;
float zinit = 150; 
IntList processedNotes;
IntList processedDurations;
void  generategCode() {
  outputGcode.clear();
  outputGcode.append("(File generated by RTTTL to Gcode)");
  outputGcode.append("(input bpm: "+defBPM.getText()+")");

  outputGcode.append("G21 (Unit in mm) G90 (Absolute distance mode) G64 P0.01 (Exact Path 0.001 tol.) G17 G40 (Cancel diameter comp.) G49 (Cancel length comp.)");

  outputGcode.append("G0 Z  90.000 ");
  outputGcode.append("T1 M6");
  outputGcode.append("S6000");
  outputGcode.append("G1 F"+ rapidfeed + " X" + xinit + " Y" + yinit + " Z" + zinit );


  int wholeNote = (60 * 1000 / int(defBPM.getText())) * 4;

  int defDur = wholeNote/int(defDuration.getText());
  int defOct = int(defOctive.getText());
  String[] notes = fileText.getTextAsArray();
  processedNotes = new IntList();
  processedDurations = new IntList();
  for (int n = 0; n < notes.length; n++) {

    int noteDuration;
    int notePitch =0;
    int noteOctive=defOct;
    int noteLoc; 
    int octLoc; 

    if (Character.isDigit(notes[n].charAt(0))) {
      if (Character.isDigit(notes[n].charAt(1))) {
        noteDuration = wholeNote/ (Character.getNumericValue(notes[n].charAt(0))*10 +  Character.getNumericValue(notes[n].charAt(1)));
        noteLoc =2;
      } else {
        noteDuration = wholeNote/(Character.getNumericValue(notes[n].charAt(0)));
        noteLoc=1;
      }
    } else {
      noteDuration = defDur;
      noteLoc=0;
    }
    switch (notes[n].toUpperCase().charAt(noteLoc)) {
    case 'P': 
      notePitch = 0;
      break;
    case 'C': 
      notePitch = 1;
      break;
    case 'D': 
      notePitch = 3;
      break;
    case 'E': 
      notePitch = 5;
      break;
    case 'F': 
      notePitch = 6;
      break;
    case 'G': 
      notePitch = 8;
      break;
    case 'A': 
      notePitch = 10;
      break;
    case 'B': 
      notePitch = 12;
      break;
    case 'H': 
      notePitch = 12;
      break;
      /* 0 - P - rest or pause
       1 - C
       2 - C# 
       3 - D 
       4 - D# 
       5 - E 
       6 - F 
       7 - F# 
       8 - G 
       9 - G# 
       10 - A 
       11 - A# 
       12 - B 
       */
    }

    if (noteLoc < notes[n].length()-1) {
      octLoc = noteLoc+1;
      if (notes[n].charAt(noteLoc+1)=='#') {
        notePitch++;
        octLoc++;
      }

      if (octLoc < notes[n].length()) {
        if (Character.isDigit(notes[n].charAt(octLoc))) {
          noteOctive = Character.getNumericValue(notes[n].charAt(octLoc));
        } else { 
          noteOctive = defOct;
        }
      }
    }

    if (notes[n].indexOf(".") != -1)
    {

      noteDuration += noteDuration/2;
    }
    if (notePitch == 0) { //if the note is a pause 
      processedDurations.add(processedDurations.size()-1, noteDuration);
    } else {
      processedNotes.append((notePitch +((noteOctive-4)*12)));
      processedDurations.append(noteDuration);
    }
  }

  float xgoal = 0;
  float ygoal = 0;
  float zgoal = 0;

  if (processedNotes.get(0) != 0) {

    xgoal = (loc.getFloat(processedNotes.get(0), 2)+xoffset+xhome);
    ygoal = (loc.getFloat(processedNotes.get(0), 3)+yoffset+yhome);
    zgoal = (loc.getFloat(processedNotes.get(0), 4)+zoffset+zhome);

    outputGcode.append("G94 f"+rapidfeed);
    outputGcode.append("g1 f"  + slowfeed + " z "+(zgoal-zleadin) ); //move to z travel height 
    outputGcode.append("g1 f"  + rapidfeed + "x"+(xgoal-xleadin)+" y" +(ygoal-yleadin) ); //move to the key position
    //outputGcode.append("g1 f"  + slowfeed + " z "+(zgoal-zleadin) ); //lower to z lead in height 
    outputGcode.append("g1 f"  +rapidfeed + " x"+(xgoal)+" y" +(ygoal) ); //strike the key 
    outputGcode.append("g1 f"  +rapidfeed + " x"+(xgoal-xleadin+2)+" y" +(ygoal-yleadin+2) ); //job done, pull out
    // outputGcode.append("g1 f"  +rapidfeed + " z "+(zinit+zoffset+zhome)); //return to travel height
  }
  for (int n = 1; n < processedNotes.size(); n++) {


    xgoal = (loc.getFloat(processedNotes.get(n), 2)+xoffset+xhome);
    //  println("Note " + n + " Number " + (processedNotes.get(n)));
    ygoal = (loc.getFloat(processedNotes.get(n), 3)+yoffset+yhome);


    zgoal = (loc.getFloat(processedNotes.get(n), 4)+zoffset+zhome);
    float zdif = zgoal - (loc.getFloat(processedNotes.get(n-1), 4)+zoffset+zhome);
    //   float travelTime = calcTravelTime((loc.getFloat(processedNotes.get(n-1), 2)),(loc.getFloat(processedNotes.get(n-1), 3)),(loc.getFloat(processedNotes.get(n), 2)),(loc.getFloat(processedNotes.get(n), 3)));
    float delayTime = processedDurations.get(n-1);


    outputGcode.append("G93");

    if (zdif == 0 ) {
      outputGcode.append("g1 f"  + (1/((((delayTime-150))/1000)/60))  + " x"+(xgoal-xleadin)+" y" +(ygoal-yleadin) ); //move to the key position
      outputGcode.append("(" + delayTime + ")");
    } else if (zdif > 0 ) {
      outputGcode.append("g1 f"  +  strikeRate + " z "+(zgoal-zleadin) );
      outputGcode.append("g1 f"  + (1/((((delayTime-225))/1000)/60))   + " x"+(xgoal-xleadin)+" y" +(ygoal-yleadin) ); //move to the key position

      outputGcode.append("(" + delayTime + ")");
    } else {

      outputGcode.append("g1 f"  + (1/((((delayTime-225))/1000)/60))  + " x"+(xgoal-xleadin)+" y" +(ygoal-yleadin) ); //move to the key position
      outputGcode.append("g1 f"  +  strikeRate + " z "+(zgoal-zleadin) );
      outputGcode.append("(" + delayTime + ")");
    }


    outputGcode.append("g1 f"  +strikeRate + " x"+(xgoal)+" y" +(ygoal) ); //strike the key 
    outputGcode.append("g1 f"  + strikeRate  + " x"+(xgoal-xleadin+2)+" y" +(ygoal-yleadin+2) ); //job done, pull out the +2 is a hack so it has to move some distance and not skip forward.
  }
  outputGcode.append("G94");
  outputGcode.append("G1 f" + slowfeed +" X0 Y0 Z0");
  outputGcode.append("M2");
  String[]finalgCode = outputGcode.array();
  gCodeText.setText(finalgCode);
}